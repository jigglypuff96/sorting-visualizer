{"ast":null,"code":"export function getMergeSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  const arrayTemp = array.slice();\n  mergeSortHelper(array, arrayTemp, 0, array.length - 1, animations);\n  return animations;\n}\n\nfunction mergeSortHelper(arrayMain, arrayTemp, startIdx, endIdx, animations) {\n  if (endIdx > startIdx) {\n    const middleIdx = Math.floor((startIdx + endIdx) / 2);\n    mergeSortHelper(arrayMain, arrayTemp, startIdx, middleIdx, animations);\n    mergeSortHelper(arrayMain, arrayTemp, middleIdx + 1, endIdx, animations);\n    doMerge(arrayMain, arrayTemp, startIdx, middleIdx + 1, endIdx, animations);\n  }\n}\n\nfunction doMerge(arrayMain, arrayTemp, startIdx, middleIdx, endIdx, animations) {\n  let k = startIdx;\n  let i = startIdx;\n  let j = middleIdx;\n  let size = endIdx - startIdx + 1;\n\n  while (i <= middleIdx - 1 && j <= endIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, j, true]);\n    animations.push([i, j, false]); // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n    // animations.push([i, j]);\n\n    if (arrayMain[i] <= arrayMain[j]) {\n      // We overwrite the value at index k in the original array with the\n      // value at index i in the auxiliary array.\n      animations.push([k, arrayMain[i]]);\n      arrayTemp[k++] = arrayMain[i++];\n    } else {\n      // We overwrite the value at index k in the original array with the\n      // value at index j in the auxiliary array.\n      animations.push([k, arrayMain[j]]);\n      arrayTemp[k++] = arrayMain[j++];\n    }\n  }\n\n  while (i <= middleIdx - 1) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, i, true]);\n    animations.push([i, i, false]); // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n    // animations.push([i, i]);\n    // We overwrite the value at index k in the original array with the\n    // value at index i in the auxiliary array.\n\n    animations.push([k, arrayMain[i]]);\n    arrayTemp[k++] = arrayMain[i++];\n  }\n\n  while (j <= endIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([j, j, true]);\n    animations.push([j, j, false]); // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n    // animations.push([j, j]);\n    // We overwrite the value at index k in the original array with the\n    // value at index j in the auxiliary array.\n\n    animations.push([k, arrayMain[j]]);\n    arrayTemp[k++] = arrayMain[j++];\n  }\n\n  for (let index = 0; index <= size; index++) {\n    arrayMain[endIdx] = arrayTemp[endIdx];\n    endIdx--;\n  }\n}","map":{"version":3,"sources":["/Users/gigizhou/Desktop/sorting-visualizer/src/sortingAlgorithms/mergeSortAlgorithm.js"],"names":["getMergeSortAnimations","array","animations","length","arrayTemp","slice","mergeSortHelper","arrayMain","startIdx","endIdx","middleIdx","Math","floor","doMerge","k","i","j","size","push","index"],"mappings":"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","sourcesContent":["export function getMergeSortAnimations(array) {\n    const animations = [];\n    if (array.length <= 1) return array;\n    const arrayTemp = array.slice();\n    mergeSortHelper(array, arrayTemp, 0, array.length - 1, animations);\n    return animations;\n  }\n  \n  function mergeSortHelper(\n    arrayMain,\n    arrayTemp,\n    startIdx,\n    endIdx,\n    animations,\n  ) {\n    if (endIdx > startIdx) {\n      const middleIdx = Math.floor((startIdx + endIdx) / 2);\n      mergeSortHelper(arrayMain, arrayTemp, startIdx, middleIdx, animations);\n      mergeSortHelper(arrayMain, arrayTemp, middleIdx + 1, endIdx, animations);\n      doMerge(arrayMain, arrayTemp, startIdx, middleIdx + 1, endIdx, animations);\n    }\n  }\n  \n  function doMerge(\n    arrayMain,\n    arrayTemp,\n    startIdx,\n    middleIdx,\n    endIdx,\n    animations,\n  ) {\n    let k = startIdx;\n    let i = startIdx;\n    let j = middleIdx;\n    let size = endIdx - startIdx + 1;\n    while (i <= middleIdx-1 && j <= endIdx) {\n      // These are the values that we're comparing; we push them once\n      // to change their color.\n      animations.push([i, j,true]);\n      animations.push([i, j,false]);\n      // These are the values that we're comparing; we push them a second\n      // time to revert their color.\n      // animations.push([i, j]);\n      if (arrayMain[i] <= arrayMain[j]) {\n        // We overwrite the value at index k in the original array with the\n        // value at index i in the auxiliary array.\n        animations.push([k, arrayMain[i]]);\n        arrayTemp[k++] = arrayMain[i++];\n      } else {\n        // We overwrite the value at index k in the original array with the\n        // value at index j in the auxiliary array.\n        animations.push([k, arrayMain[j]]);\n        arrayTemp[k++] = arrayMain[j++];\n      }\n    }\n    while (i <= middleIdx-1) {\n      // These are the values that we're comparing; we push them once\n      // to change their color.\n      animations.push([i, i,true]);\n      animations.push([i, i,false]);\n      // These are the values that we're comparing; we push them a second\n      // time to revert their color.\n      // animations.push([i, i]);\n      // We overwrite the value at index k in the original array with the\n      // value at index i in the auxiliary array.\n      animations.push([k, arrayMain[i]]);\n      arrayTemp[k++] = arrayMain[i++];\n    }\n    while (j <= endIdx) {\n      // These are the values that we're comparing; we push them once\n      // to change their color.\n      animations.push([j, j,true]);\n      animations.push([j, j,false]);\n      // These are the values that we're comparing; we push them a second\n      // time to revert their color.\n      // animations.push([j, j]);\n      // We overwrite the value at index k in the original array with the\n      // value at index j in the auxiliary array.\n      animations.push([k, arrayMain[j]]);\n      arrayTemp[k++] = arrayMain[j++];\n    }\n    for (let index = 0; index<=size; index++){\n      arrayMain[endIdx] = arrayTemp[endIdx];\n      endIdx--;\n    }\n  }\n  "]},"metadata":{},"sourceType":"module"}